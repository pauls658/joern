.decl edge(start:number, end:number)
.decl branch(stmt:number)
.decl def(stmt:number, var:number)
.decl star_def(stmt:number, var:number)
.decl use(stmt:number, var:number)
.decl source(stmt:number)
.decl sink(stmt:number)
.decl tainted(stmt:number)
.decl tainted_sink(stmt:number)
.decl nokill(stmt:number)
.decl kill(stmt:number, var:number)
.decl datadep(def_stmt:number, use_stmt:number, var:number)
// n is control dependent on d
// if d is tainted, then n is too
//.decl ctrldep(n:number, d:number)
.decl safebranch(n:number)
.decl ctrldef(stmt:number, var:number)
.decl livectrldef(stmt:number, var:number)
//.decl taintedCtrldep(n:number)
.decl tainted_branch(def_stmt:number)

.input edge(IO=file, filename="tmp/edge.csv")
.input branch(IO=file, filename="tmp/branch.csv")
//.input ctrldep(IO=file, filename="tmp/ctrldep.csv")
.input safebranch(IO=file, filename="tmp/safebranch.csv")
.input ctrldef(IO=file, filename="tmp/ctrldef.csv")
.input def(IO=file, filename="tmp/def.csv")
.input star_def(IO=file, filename="tmp/star_def.csv")
.input use(IO=file, filename="tmp/use.csv")
.input source(IO=file, filename="tmp/source.csv")
.input sink(IO=file, filename="tmp/sink.csv")
.input nokill(IO=file, filename="tmp/nokill.csv")
.input kill(IO=file, filename="tmp/kill.csv")

.decl livedef(var:number, def_stmt:number, this_stmt:number)

/* This program will track the explicit ctrldef's
   and output which branches will have implicit
   flows */

// only init liveness for source variables
livedef(def_stmt, var, def_stmt) :- def(def_stmt, var), source(def_stmt).

// propogate liveness for initial source
livedef(prev_stmt, var, this_stmt) :- livedef(prev_stmt, var, prev_stmt), edge(prev_stmt, this_stmt).

// propogate liveness until we reach an assignment
// if there is no def of the var at this statement, we always let the def pass
livedef(def_stmt, var, this_stmt) :- livedef(def_stmt, var, prev_stmt), edge(prev_stmt, this_stmt), !def(prev_stmt, var), !kill(prev_stmt, var).
// or, if there is a def, but this is a special non-killing statement (e.g. recursive call), let the def pass
livedef(def_stmt, var, this_stmt) :- livedef(def_stmt, var, prev_stmt), edge(prev_stmt, this_stmt), nokill(prev_stmt).
// or if there is a def, but the live def is a star def, and this is not a killing statement (e.g. a CFG func exit), then
// let the def pass
livedef(def_stmt, var, this_stmt) :- livedef(def_stmt, var, prev_stmt), edge(prev_stmt, this_stmt), star_def(def_stmt, var), !kill(prev_stmt, var).

// statements that use a live def are tainted
tainted(this_stmt) :- livedef(def_stmt, var, this_stmt), use(this_stmt, var).

// make a livedef for each def'd variable at a tainted statement
livedef(def_stmt, var, def_stmt) :- tainted(def_stmt), def(def_stmt, var).

// get tainted sinks
tainted_sink(this_stmt) :- sink(this_stmt), tainted(this_stmt).

// compute data dependences
datadep(def_stmt, use_stmt, var) :- livedef(def_stmt, var, use_stmt), use(use_stmt, var).

// propagate the ctrldefs
// if stmt1 uses var2, and var2 is live at stmt1, and the live def of var2 is a ctrldef,
// then each def'd var at stmt1 is a ctrldef
ctrldef(stmt1, var1) :- def(stmt1, var1), use(stmt1, var2), livedef(stmt2, var2, stmt1), ctrldef(stmt2, var2).
livectrldef(stmt, var) :- ctrldef(stmt, var), livedef(stmt, var, stmt1).


tainted_branch(stmt1) :- use(stmt1, var1), livedef(stmt2, var1, stmt1), ctrldef(stmt2, var1), branch(stmt1), !safebranch(stmt1).

//tainted_branch(stmt) :- branch(stmt), tainted(stmt).

.output tainted_sink
.output datadep
//.output livedef
//.output livectrldef
.output tainted_branch
